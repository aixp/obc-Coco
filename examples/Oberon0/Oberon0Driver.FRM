(* driver module generated by Coco-R *)
MODULE -->modulename; 

	(*
		A. V. Shiryaev, 2012.01
	*)

	IMPORT S:=-->scanner, P:=-->parser, OSG, Oberon, Texts;

	CONST minErrDist = 8;

	VAR
		W: Texts.Writer; lastErrPos: LONGINT;

	PROCEDURE Error (n: INTEGER; pos: LONGINT);

		PROCEDURE Msg (s: ARRAY OF CHAR);
		BEGIN
			Texts.WriteString(W, s)
		END Msg;

	BEGIN
		INC(S.errors);
		IF pos < lastErrPos + minErrDist THEN lastErrPos := pos; RETURN END ;
		lastErrPos := pos;
		Texts.WriteString(W, "	pos "); Texts.WriteInt(W, pos, 3); Texts.WriteString(W, ": ");
		IF n < 200 THEN
			CASE n OF-->errors
			ELSE Texts.WriteString(W, "error "); Texts.WriteInt(W, n, 0)
			END
		ELSE
			CASE n OF
			ELSE Texts.WriteString(W, "error "); Texts.WriteInt(W, n, 0)
			END
		END;
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Error;

	PROCEDURE Do;
		VAR src: Texts.Text;
	BEGIN
		src := Oberon.MarkedText();
		IF src # NIL THEN
			Texts.WriteString(W, "Oberon-0 compiler"); (* -->name *) Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf);

			S.Reset(src, 0, Error); lastErrPos := -10;
			P.Parse;
			IF S.errors = 0 THEN
				Texts.WriteString(W, "Listing:"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
				OSG.Decode;
				Texts.WriteString(W, "Executing:"); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf);
				OSG.Execute;
				Texts.WriteString(W, "All done."); Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
			ELSE
				Texts.WriteInt(W, S.errors, 0); Texts.WriteString(W, " errors"); Texts.WriteLn(W);
				Texts.Append(Oberon.Log, W.buf)
			END
		END
	END Do;

BEGIN
	Texts.OpenWriter(W);
	Do
END -->modulename.
