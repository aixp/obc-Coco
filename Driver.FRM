(* driver module generated by Coco-R *)
MODULE -->modulename; 

	(*
		
	*)

	IMPORT S:=-->scanner, P:=-->parser, Oberon, Texts;

	CONST minErrDist = 8;

	VAR
		W: Texts.Writer; lastErrPos: LONGINT;

	PROCEDURE Error (n: INTEGER; pos: LONGINT);

		PROCEDURE Msg (s: ARRAY OF CHAR);
		BEGIN
			Texts.WriteString(W, s)
		END Msg;

	BEGIN
		INC(S.errors);
		IF pos < lastErrPos + minErrDist THEN lastErrPos := pos; RETURN END ;
		lastErrPos := pos;
		Texts.WriteString(W, "	pos "); Texts.WriteInt(W, pos, 3); Texts.WriteString(W, ": ");
		IF n < 200 THEN
			CASE n OF-->errors
			ELSE Texts.WriteString(W, "error "); Texts.WriteInt(W, n, 0)
			END
		ELSE
			CASE n OF
			ELSE Texts.WriteString(W, "error "); Texts.WriteInt(W, n, 0)
			END
		END;
		Texts.WriteLn(W); Texts.Append(Oberon.Log, W.buf)
	END Error;

	PROCEDURE Do;
		VAR src: Texts.Text;
	BEGIN
		src := Oberon.MarkedText();
		IF src # NIL THEN
			Texts.WriteString(W, "-->name compiler"); Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf);

			S.Reset(src, 0, Error); lastErrPos := -10;
			P.Parse;
			Texts.WriteInt(W, S.errors, 0); Texts.WriteString(W, " errors"); Texts.WriteLn(W);
			Texts.Append(Oberon.Log, W.buf)
		END
	END Do;

BEGIN
	Texts.OpenWriter(W);
	Do
END -->modulename.
